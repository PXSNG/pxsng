-- #############################################
-- 0. INITIALISIERUNG & KONSTANTEN
-- #############################################
WHENEVER SQLERROR EXIT 1;

-- Werte werden via SQL*Plus DEFINE aus der Umgebung gesetzt (siehe setup.sh).
DEFINE APP_USER = &&APP_USER
DEFINE APP_USER_PWD = &&APP_USER_PWD
DEFINE REST_SCHEMA = &APP_USER

-- #############################################
-- 1. APP-BENUTZER ERSTELLEN & RECHTE ZUWEISEN
-- #############################################
alter session set container = freepdb1;
pro    1.1 Benutzer &REST_SCHEMA erstellen...
create user &rest_schema identified by "&APP_USER_PWD"
   default tablespace users
   quota 500M on users;
alter user &rest_schema
   account unlock;
grant create session,
   create table,
   create view,
   create procedure,
   create sequence,
   create trigger
to &rest_schema;
grant select on sys.dba_registry to &rest_schema;

-- #############################################
-- 2. DDL AUSFÃœHREN (ALS APP_REST_USER)
-- #############################################

alter session set current_schema = &rest_schema;

create table "COUNTRY" (
   "ID"               number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "COUNTRY"          varchar2(255) not null,
   "COUNTRY_ABBR"     varchar2(10) not null,
   "ITU_COUNTRY_CODE" number(3) not null
);

create table "ZIPCODE" (
   "COUNTRY_ID"  number not null,
   "ZIP"         varchar2(20) not null,
   "CITY"        varchar2(255) not null,
   "REGION_NAME" varchar2(255),
   primary key ( "COUNTRY_ID",
                 "ZIP" )
);

create table "PROMO_CODE" (
   "ID"                  number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "CODE"                varchar2(50) unique not null,
   "DISCOUNT_PERCENTAGE" number(3) not null check ( "DISCOUNT_PERCENTAGE" between 0 and 100 ),
   "EXPIRES_AT"          date not null,
   "CREATED_AT"          timestamp not null,
   "UPDATED_AT"          timestamp
);

create table "ADDRESS" (
   "ID"               number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "ADDITIONAL_FIELD" varchar2(255),
   "HOUSENUMBER"      varchar2(50) not null,
   "STREET"           varchar2(255) not null,
   "ZIPCODE"          varchar2(20) not null,
   "COUNTRY_ID"       number
);

create table "COMPANY" (
   "ID"           varchar2(36) primary key,
   "NAME"         varchar2(255) not null,
   "SPOKESPERSON" varchar2(255) not null,
   "TELEPHONE"    varchar2(50) not null,
   "ADDRESS_ID"   number,
   "MANAGER_USER" varchar2(36) -- References USER(ID) (UUID)
);

create table "REFERRAL" (
   "ID"             varchar2(36) primary key,
   "ORIGIN_USER_ID" varchar2(36), -- References USER(ID) (UUID)
   "CODE"           varchar2(50) unique not null
);

create table "APP_USER" (
   "ID"                     varchar2(36) primary key,
   "FIRSTNAME"              varchar2(255) not null,
   "LASTNAME"               varchar2(255) not null,
   "EMAIL"                  varchar2(255) unique not null,
   "TELEPHONE"              varchar2(50),
   "REFERRAL_CODE_ID"       varchar2(36), -- References REFERRAL(ID) (UUID)
   "PASSWORD_HASH"          varchar2(255) not null,
   "ADDRESS_ID"             number,
   "IS_PREMIUM"             char(1) not null check ( "IS_PREMIUM" in ( 'Y',
                                                           'N' ) ),
   "IS_COMPANY_MANAGER"     char(1) not null check ( "IS_COMPANY_MANAGER" in ( 'Y',
                                                                           'N' ) ),
   "COIN_BALANCE"           number default 0 not null,
   "SHOPPING_CART"          varchar2(36), -- References SHOPPINGCART(ID) (UUID)
   "CONTENT_PREFERENCES_ID" number,
   "CREATED_AT"             timestamp not null,
   "UPDATED_AT"             timestamp
);

create table "PARTICIPANT" (
   "ID"         number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "USER_ID"    varchar2(36), -- References USER(ID) (UUID)
   "CREATED_AT" timestamp not null,
   "UPDATED_AT" timestamp
);

create table "CATEGORY" (
   "ID"    number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "LABEL" varchar2(255) unique not null
);

create table "COURSE" (
   "ID"               number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "TITLE"            varchar2(255) not null,
   "DESCRIPTION"      clob,
   "PRICE"            number(10,2) not null check ( "PRICE" >= 0 ),
   "DURATION_DAYS"    number(3) check ( "DURATION_DAYS" > 0 ),
   "MAX_PARTICIPANTS" number(5) check ( "MAX_PARTICIPANTS" > 0 ),
   "CATEGORY_ID"      number,
   "CREATED_AT"       timestamp not null,
   "UPDATED_AT"       timestamp
);

create table "COURSE_BOOKING" (
   "ID"             varchar2(36) primary key,
   "PARTICIPANT_ID" number not null,
   "COURSE_ID"      number not null,
   "BOOKING_DATE"   timestamp not null,
   "STATUS"         varchar2(50)
);

create table "OFFER" (
   "ID"                  number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "USER_ID"             varchar2(36) not null, -- References USER(ID) (UUID)
   "STATUS"              varchar2(50),
   "DISCOUNT_PERCENTAGE" number(3),
   "UNDISCOUNTED_PRICE"  number(10,2) not null,
   "TOTAL_PRICE"         number(10,2) not null,
   "DOCUMENT_ID"         varchar2(36), -- References DOCUMENT(ID) (UUID)
   "CREATED_AT"          timestamp not null,
   "UPDATED_AT"          timestamp
);

create table "BILLING" (
   "ID"                 number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "USER_ID"            varchar2(36) not null, -- References USER(ID) (UUID)
   "OFFER_ID"           number,
   "BILLING_ADDRESS_ID" number,
   "BILLING_DATE"       timestamp not null,
   "DOCUMENT_ID"        varchar2(36), -- References DOCUMENT(ID) (UUID)
   "DUE_AT"             timestamp,
   "STATUS"             varchar2(50) not null,
   "TOTAL_DUE"          number(10,2) not null
);

create table "CERTIFICATE" (
   "ID"               varchar2(36) primary key,
   "USER_ID"          varchar2(36) not null, -- References USER(ID) (UUID)
   "COURSE_ID"        number not null,
   "CERTIFICATE_CODE" varchar2(50) unique not null,
   "DOCUMENT_ID"      varchar2(36), -- References DOCUMENT(ID) (UUID)
   "EXPIRES_AT"       date,
   "CREATED_AT"       date not null
);

create table "DOCUMENT" (
   "ID"             varchar2(36) primary key,
   "TYPE"           varchar2(50) not null check ( "TYPE" in ( 'Offer',
                                                    'Invoice',
                                                    'Certificate' ) ),
   "REFERENCE_TYPE" varchar2(50) not null,
   "REFERENCE_ID"   varchar2(36) not null,
   "FILENAME"       varchar2(255) not null,
   "PATH"           varchar2(255) not null,
   "CREATED_AT"     timestamp not null
);

create table "SHOPPINGCART" (
   "ID"         varchar2(36) primary key,
   "CREATED_AT" timestamp not null,
   "UPDATED_AT" timestamp
);

create table "CARTITEM" (
   "ID"         number generated by default on null as identity ( start with 1 increment by 1 ) primary key,
   "QUANTITY"   number(3) not null check ( "QUANTITY" > 0 ),
   "CART_ID"    varchar2(36) not null, -- References SHOPPINGCART(ID) (UUID)
   "COURSE_ID"  number not null,
   "CREATED_AT" timestamp not null,
   "UPDATED_AT" timestamp
);

alter table "ZIPCODE"
   add constraint fk_zipcode_country_id foreign key ( "COUNTRY_ID" )
      references "COUNTRY" ( "ID" );

alter table "ADDRESS" add (
   "ZIPCODE_COUNTRY_ID" number,
   constraint fk_address_zipcode
      foreign key ( "ZIPCODE_COUNTRY_ID",
                    "ZIPCODE" )
         references "ZIPCODE" ( "COUNTRY_ID",
                                "ZIP" )
);

declare
   v_cnt number;
begin
   select count(*)
     into v_cnt
     from user_constraints
    where table_name = 'ADDRESS'
      and constraint_name = 'FK_ADDRESS_ZIPCODE_ORIG';

   if v_cnt > 0 then
      execute immediate 'alter table "ADDRESS" drop constraint fk_address_zipcode_orig';
   end if;
end;
/

alter table "ADDRESS"
   add constraint fk_address_country_id foreign key ( "COUNTRY_ID" )
      references "COUNTRY" ( "ID" );

alter table "COMPANY"
   add constraint fk_company_address_id foreign key ( "ADDRESS_ID" )
      references "ADDRESS" ( "ID" );

alter table "COMPANY"
   add constraint fk_company_manager_user
      foreign key ( "MANAGER_USER" )
         references "APP_USER" ( "ID" )
         deferrable initially deferred;

alter table "REFERRAL"
   add constraint fk_referral_origin_user_id
      foreign key ( "ORIGIN_USER_ID" )
         references "APP_USER" ( "ID" )
         deferrable initially deferred;

alter table "APP_USER"
   add constraint fk_user_referral_code_id
      foreign key ( "REFERRAL_CODE_ID" )
         references "REFERRAL" ( "ID" )
         deferrable initially deferred;

alter table "APP_USER"
   add constraint fk_user_address_id foreign key ( "ADDRESS_ID" )
      references "ADDRESS" ( "ID" );

alter table "APP_USER"
   add constraint fk_user_shopping_cart foreign key ( "SHOPPING_CART" )
      references "SHOPPINGCART" ( "ID" );

alter table "APP_USER"
   add constraint fk_user_content_prefs foreign key ( "CONTENT_PREFERENCES_ID" )
      references "CATEGORY" ( "ID" );

alter table "PARTICIPANT"
   add constraint fk_participant_user_id foreign key ( "USER_ID" )
      references "APP_USER" ( "ID" );

alter table "COURSE"
   add constraint fk_course_category_id foreign key ( "CATEGORY_ID" )
      references "CATEGORY" ( "ID" );

alter table "COURSE_BOOKING"
   add constraint fk_booking_participant_id foreign key ( "PARTICIPANT_ID" )
      references "PARTICIPANT" ( "ID" );

alter table "COURSE_BOOKING"
   add constraint fk_booking_course_id foreign key ( "COURSE_ID" )
      references "COURSE" ( "ID" );

alter table "OFFER"
   add constraint fk_offer_user_id foreign key ( "USER_ID" )
      references "APP_USER" ( "ID" );

alter table "OFFER"
   add constraint fk_offer_document_id foreign key ( "DOCUMENT_ID" )
      references "DOCUMENT" ( "ID" );

alter table "BILLING"
   add constraint fk_billing_user_id foreign key ( "USER_ID" )
      references "APP_USER" ( "ID" );

alter table "BILLING"
   add constraint fk_billing_offer_id foreign key ( "OFFER_ID" )
      references "OFFER" ( "ID" );

alter table "BILLING"
   add constraint fk_billing_address_id foreign key ( "BILLING_ADDRESS_ID" )
      references "ADDRESS" ( "ID" );

alter table "BILLING"
   add constraint fk_billing_document_id foreign key ( "DOCUMENT_ID" )
      references "DOCUMENT" ( "ID" );

alter table "CERTIFICATE"
   add constraint fk_certificate_user_id foreign key ( "USER_ID" )
      references "APP_USER" ( "ID" );

alter table "CERTIFICATE"
   add constraint fk_certificate_course_id foreign key ( "COURSE_ID" )
      references "COURSE" ( "ID" );

alter table "CERTIFICATE"
   add constraint fk_certificate_document_id foreign key ( "DOCUMENT_ID" )
      references "DOCUMENT" ( "ID" );

alter table "CARTITEM"
   add constraint fk_cartitem_cart_id
      foreign key ( "CART_ID" )
         references "SHOPPINGCART" ( "ID" )
            on delete cascade;

alter table "CARTITEM"
   add constraint fk_cartitem_course_id foreign key ( "COURSE_ID" )
      references "COURSE" ( "ID" );

-- #############################################
-- 2.5 PERFORMANCE INDEXES
-- #############################################

create index idx_zipcode_country_id on
   "ZIPCODE" (
      "COUNTRY_ID"
   );
create index idx_address_country_id on
   "ADDRESS" (
      "COUNTRY_ID"
   );
create index idx_company_address_id on
   "COMPANY" (
      "ADDRESS_ID"
   );
create index idx_company_manager_user on
   "COMPANY" (
      "MANAGER_USER"
   );
create index idx_referral_origin_user on
   "REFERRAL" (
      "ORIGIN_USER_ID"
   );
create index idx_user_referral_code on
   "APP_USER" (
      "REFERRAL_CODE_ID"
   );
create index idx_user_address_id on
   "APP_USER" (
      "ADDRESS_ID"
   );
create index idx_user_shopping_cart on
   "APP_USER" (
      "SHOPPING_CART"
   );
create index idx_user_content_prefs on
   "APP_USER" (
      "CONTENT_PREFERENCES_ID"
   );
create index idx_participant_user_id on
   "PARTICIPANT" (
      "USER_ID"
   );
create index idx_course_category_id on
   "COURSE" (
      "CATEGORY_ID"
   );
create index idx_booking_participant on
   "COURSE_BOOKING" (
      "PARTICIPANT_ID"
   );
create index idx_booking_course on
   "COURSE_BOOKING" (
      "COURSE_ID"
   );
create index idx_offer_user_id on
   "OFFER" (
      "USER_ID"
   );
create index idx_offer_document_id on
   "OFFER" (
      "DOCUMENT_ID"
   );
create index idx_billing_user_id on
   "BILLING" (
      "USER_ID"
   );
create index idx_billing_offer_id on
   "BILLING" (
      "OFFER_ID"
   );
create index idx_billing_address_id on
   "BILLING" (
      "BILLING_ADDRESS_ID"
   );
create index idx_billing_document_id on
   "BILLING" (
      "DOCUMENT_ID"
   );
create index idx_certificate_user_id on
   "CERTIFICATE" (
      "USER_ID"
   );
create index idx_certificate_course_id on
   "CERTIFICATE" (
      "COURSE_ID"
   );
create index idx_certificate_doc_id on
   "CERTIFICATE" (
      "DOCUMENT_ID"
   );
create index idx_cartitem_cart_id on
   "CARTITEM" (
      "CART_ID"
   );
create index idx_cartitem_course_id on
   "CARTITEM" (
      "COURSE_ID"
   );

create index idx_booking_status on
   "COURSE_BOOKING" (
      "STATUS"
   );
create index idx_billing_status on
   "BILLING" (
      "STATUS"
   );
create index idx_offer_status on
   "OFFER" (
      "STATUS"
   );

-- #############################################
-- 3. PL/SQL PACKAGES ERSTELLEN
-- #############################################

pro    3.1 USER_API_PKG erstellen...


create or replace package user_api_pkg as
   procedure create_user_record (
      p_json_body        in clob,
      p_status_code      out number,
      p_response_message out clob
   );

   procedure get_user_by_id (
      p_user_id     in varchar2,
      p_user_cursor out sys_refcursor
   );

   procedure delete_user_record (
      p_user_id          in varchar2,
      p_status_code      out number,
      p_response_message out clob
   );

end user_api_pkg;
/

-- #############################################
-- PACKAGE BODY (Implementierung)
-- #############################################
create or replace package body user_api_pkg as

   procedure create_user_record (
      p_json_body        in clob,
      p_status_code      out number,
      p_response_message out clob
   ) is
      v_user_id "APP_USER"."ID"%type := rawtohex(sys_guid());
      v_cart_id "SHOPPINGCART"."ID"%type := rawtohex(sys_guid());
   begin
      insert into "SHOPPINGCART" (
         id,
         created_at,
         updated_at
      ) values ( v_cart_id,
                 current_timestamp,
                 current_timestamp );

      insert into "APP_USER" (
         id,
         firstname,
         lastname,
         email,
         password_hash,
         is_premium,
         is_company_manager,
         coin_balance,
         shopping_cart,
         created_at,
         updated_at
      ) values ( v_user_id,
                 json_value(p_json_body,
                            '$.firstname'),
                 json_value(p_json_body,
                            '$.lastname'),
                 json_value(p_json_body,
                            '$.email'),
                 json_value(p_json_body,
                            '$.password_hash'),
                 to_char(coalesce(
                    json_value(p_json_body,
                               '$.is_premium'),
                    'N'
                 )),
                 to_char(coalesce(
                    json_value(p_json_body,
                               '$.is_company_manager'),
                    'N'
                 )),
                 to_number(coalesce(
                    json_value(p_json_body,
                               '$.coin_balance' returning number),
                    0
                 )),
                 v_cart_id,
                 current_timestamp,
                 current_timestamp );
      p_status_code := 201;
      p_response_message := '{"success": true, "id": "'
                            || v_user_id
                            || '", "message": "User created"}';
      commit;
   exception
      when others then
         p_status_code := 400;
         p_response_message := '{"success": false, "message": "'
                               || sqlerrm
                               || '"}';
         rollback;
   end create_user_record;

   procedure get_user_by_id (
      p_user_id     in varchar2,
      p_user_cursor out sys_refcursor
   ) is
   begin
      open p_user_cursor for select *
                                                      from "APP_USER"
                              where id = p_user_id;
   end get_user_by_id;

   procedure delete_user_record (
      p_user_id          in varchar2,
      p_status_code      out number,
      p_response_message out clob
   ) is
   begin
      delete from "APP_USER"
       where id = p_user_id;
      if sql%rowcount = 0 then
         p_status_code := 404;
         p_response_message := '{
   "success": false,
   "message": "User ID not found"
}';
         rollback;
      else
         p_status_code := 200;
         p_response_message := '{
   "success": true,
   "message": "User deleted"
}';
         commit;
      end if;
   exception
      when others then
         p_status_code := 500;
         p_response_message := '{"success": false, "message": "'
                               || sqlerrm
                               || '"}';
         rollback;
   end delete_user_record;

end user_api_pkg;
/
SHOW ERRORS

-- #############################################
-- 4. COURSE_API_PKG ERSTELLEN
-- #############################################

pro    4.1 COURSE_API_PKG erstellen...

create or replace package course_api_pkg as
   procedure get_all_courses (
      p_courses_cursor out sys_refcursor
   );

   procedure get_course_by_id (
      p_course_id     in number,
      p_course_cursor out sys_refcursor
   );
end course_api_pkg;
/

create or replace package body course_api_pkg as

   procedure get_all_courses (
      p_courses_cursor out sys_refcursor
   ) is
   begin
      open p_courses_cursor for select id,
                                       title,
                                       description,
                                       price,
                                       duration_days,
                                       max_participants,
                                       category_id,
                                       created_at,
                                       updated_at
                                                            from "COURSE"
                                 order by created_at desc;
   end get_all_courses;

   procedure get_course_by_id (
      p_course_id     in number,
      p_course_cursor out sys_refcursor
   ) is
   begin
      open p_course_cursor for select *
                                                          from "COURSE"
                                where id = p_course_id;
   end get_course_by_id;

end course_api_pkg;
/
SHOW ERRORS

-- #############################################
-- 5. AUTO-UPDATE TRIGGERS FOR UPDATED_AT
-- #############################################

pro    5.1 Creating auto-update triggers...

create or replace trigger trg_promo_code_updated_at before
   update on "PROMO_CODE"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

create or replace trigger trg_user_updated_at before
   update on "APP_USER"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

create or replace trigger trg_participant_updated_at before
   update on "PARTICIPANT"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

create or replace trigger trg_course_updated_at before
   update on "COURSE"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

create or replace trigger trg_offer_updated_at before
   update on "OFFER"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

create or replace trigger trg_cartitem_updated_at before
   update on "CARTITEM"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

create or replace trigger trg_shoppingcart_updated_at before
   update on "SHOPPINGCART"
   for each row
begin
   :new.updated_at := current_timestamp;
end;
/

SHOW ERRORS